<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Gilad Naaman</title>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="/stylesheet.css" type="text/css">
    </head>
    <body>
        <div id="header">
            <a id="title" href="/">Gilad Naaman</a>

            <div id="tray">
                <a href="https://www.linkedin.com/in/gilad-naaman-b6164214a/">linky dinky</a>
                <a href="https://github.com/Gilnaa">code</a>
                <a href="/blog">blog</a>
            </div>
        </div>
        <section class="section">
           <div class="container">
               
<h1 class="title">
  Kernel GRE bug post-mortem
</h1>
<p class="subtitle"><strong>2021-07-27</strong></p>
<p>At the time of writing this post, I am part of the Infra group of <a href="https://drivenets.com/">Drivenets</a>.
Some time ago we started to upgrade our Ubuntu machines at work to the latest LTS, Ubuntu 20.04.</p>
<p>For a few weeks, everything was fine; but peace is only ever temporary.</p>
<p><img src="/imgs/bug-report.png" alt="badly drawn jira ticket with title &quot;very bug i donâ€™t have IPv4 traffic on some of our machines this is a very real bug title oh boi&quot;" title="A real screenshot" /></p>
<p><em>just</em> ipv4, but <em>all</em> ipv4?</p>
<p>Oh no.</p>
<h2 id="initial-analysis">Initial Analysis</h2>
<p>Arriving to the crime scene, there were clear signs of foul play.</p>
<p>We make heavy usage of L2-<a href="https://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">GRE</a>s <sup><a href="/blurb/gre">1</a></sup> in some of our products,
usually assigning them a MAC address matching one of an actual physical interface somewhere.</p>
<p>A cursory glance at <code>tcpdump</code>'s output for the faulty GRE interface shows that IPv4 traffic <em>does</em> reach us, and it even <em>seems</em> to have the correct MAC and IP addresses.
Why would the kernel ignore this ICMP request?</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#d08770;">19</span><span>:</span><span style="color:#d08770;">05</span><span>:</span><span style="color:#d08770;">17.680821 18</span><span>:be:</span><span style="color:#d08770;">92</span><span>:a0:6c:</span><span style="color:#d08770;">06 </span><span>&gt; </span><span style="color:#d08770;">18</span><span>:bd:</span><span style="color:#d08770;">92</span><span>:a0:ee:</span><span style="color:#d08770;">26</span><span>, IPv4, length </span><span style="color:#d08770;">98</span><span>: (tos </span><span style="color:#d08770;">0x0</span><span>, ttl </span><span style="color:#d08770;">...</span><span>
</span><span>    </span><span style="color:#d08770;">130.130.130.1 </span><span>&gt; </span><span style="color:#d08770;">130.130.130.2</span><span>: </span><span style="color:#bf616a;">ICMP </span><span>echo request, </span><span style="color:#96b5b4;">id </span><span style="color:#d08770;">20718</span><span>, seq </span><span style="color:#d08770;">1</span><span>, length </span><span style="color:#d08770;">64</span><span>
</span></code></pre>
<p>Oh wait ğŸ˜¯ both mac addresses are slightly wrong; no wonder the kernel drops these.
If we inspect the packet as it gets sent...</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#d08770;">22</span><span>:</span><span style="color:#d08770;">29</span><span>:</span><span style="color:#d08770;">49.000231 18</span><span>:be:</span><span style="color:#d08770;">92</span><span>:a0:6c:</span><span style="color:#d08770;">05 </span><span>&gt; </span><span style="color:#d08770;">18</span><span>:be:</span><span style="color:#d08770;">92</span><span>:a0:ee:</span><span style="color:#d08770;">26</span><span>, IPv4, length </span><span style="color:#d08770;">98</span><span>: (tos </span><span style="color:#d08770;">0x0</span><span>, ttl </span><span style="color:#d08770;">...</span><span>
</span><span>    </span><span style="color:#d08770;">130.130.130.1 </span><span>&gt; </span><span style="color:#d08770;">130.130.130.2</span><span>: </span><span style="color:#bf616a;">ICMP </span><span>echo request, </span><span style="color:#96b5b4;">id </span><span style="color:#d08770;">20718</span><span>, seq </span><span style="color:#d08770;">1</span><span>, length </span><span style="color:#d08770;">64</span><span>
</span></code></pre>
<blockquote>
<p>&quot;well boss, I found the problem, we're off by 3 bits â€”</p>
<p>â€” oh, I also have to fix that?&quot;</p>
</blockquote>
<h2 id="first-clue">First Clue</h2>
<p>After contemplating my existence for a bit, trying to figure out if life is worth debugging this, I started opening various log files.</p>
<p>Running <code>dmesg</code>, I saw an endless stream of</p>
<pre data-lang="dmesg" style="background-color:#2b303b;color:#c0c5ce;" class="language-dmesg "><code class="language-dmesg" data-lang="dmesg"><span>[78005.657058] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78005.657127] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78005.657170] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78005.657252] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78005.657884] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78010.657871] net_ratelimit: 10 callbacks suppressed</span><span>
</span><span>[78010.657873] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78010.657887] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78010.657922] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78010.657971] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78010.658008] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span><span>[78010.658035] ip_tunnel: non-ECT from 10.254.3.1 with TOS=0x1</span><span>
</span></code></pre>
<p>Suspicious. When is this logged?
After cloning vanilla Linux kernel and checking out the v5.4 tag, I found the source:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">// net/ipv4/ip_tunnel.c ~L393</span><span style="color:#65737e;">
</span><span>    </span><span style="color:#bf616a;">skb_reset_network_header</span><span>(skb);</span><span>
</span><span>
</span><span>    err = </span><span style="color:#bf616a;">IP_ECN_decapsulate</span><span>(iph, skb);</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">unlikely</span><span>(err)) {</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>(log_ecn_error)</span><span>
</span><span>            </span><span style="color:#bf616a;">net_info_ratelimited</span><span>(&quot;</span><span style="color:#a3be8c;">non-ECT from </span><span style="color:#d08770;">%p</span><span style="color:#a3be8c;">I4 with TOS=</span><span style="color:#d08770;">%#x</span><span style="color:#96b5b4;">\n</span><span>&quot;,</span><span>
</span><span>                    &amp;iph-&gt;saddr, iph-&gt;tos);</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>(err &gt; </span><span style="color:#d08770;">1</span><span>) {</span><span>
</span><span>            ++tunnel-&gt;dev-&gt;stats.</span><span style="color:#bf616a;">rx_frame_errors</span><span>;</span><span>
</span><span>            ++tunnel-&gt;dev-&gt;stats.</span><span style="color:#bf616a;">rx_errors</span><span>;</span><span>
</span><span>            </span><span style="color:#b48ead;">goto</span><span> drop;</span><span>
</span><span>        }</span><span>
</span><span>    }</span><span>
</span></code></pre>
<p>Going further into <code>IP_ECN_decapsulate</code>: (skipping a few layers for brevity)</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">/*</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> * RFC 6040 4.2</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *  To decapsulate the inner header at the tunnel egress, a compliant</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *  tunnel egress MUST set the outgoing ECN field to the codepoint at the</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *  intersection of the appropriate arriving inner header (row) and outer</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *  header (column) in Figure 4</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      +---------+------------------------------------------------+</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      |Arriving |            Arriving Outer Header               |</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      |   Inner +---------+------------+------------+------------+</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      |  Header | Not-ECT | ECT(0)     | ECT(1)     |     CE     |</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      +---------+---------+------------+------------+------------+</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      | Not-ECT | Not-ECT |Not-ECT(!!!)|Not-ECT(!!!)| &lt;drop&gt;(!!!)|</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      |  ECT(0) |  ECT(0) | ECT(0)     | ECT(1)     |     CE     |</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      |  ECT(1) |  ECT(1) | ECT(1) (!) | ECT(1)     |     CE     |</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      |    CE   |      CE |     CE     |     CE(!!!)|     CE     |</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *      +---------+---------+------------+------------+------------+</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *             Figure 4: New IP in IP Decapsulation Behaviour</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *  returns 0 on success</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *          1 if something is broken and should be logged (!!! above)</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> *          2 if packet should be dropped</span><span style="color:#65737e;">
</span><span style="color:#65737e;"> */</span><span>
</span><span style="color:#b48ead;">static inline int </span><span style="color:#8fa1b3;">__INET_ECN_decapsulate</span><span>(__u8 </span><span style="color:#bf616a;">outer</span><span>, __u8 </span><span style="color:#bf616a;">inner</span><span>, </span><span style="color:#b48ead;">bool </span><span>*</span><span style="color:#bf616a;">set_ce</span><span>)</span><span>
</span><span>{</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">INET_ECN_is_not_ect</span><span>(inner)) {</span><span>
</span><span>        </span><span style="color:#b48ead;">switch </span><span>(outer &amp; INET_ECN_MASK) {</span><span>
</span><span>        </span><span style="color:#b48ead;">case</span><span> INET_ECN_NOT_ECT:</span><span>
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;</span><span>
</span><span>        </span><span style="color:#b48ead;">case</span><span> INET_ECN_ECT_0:</span><span>
</span><span>        </span><span style="color:#b48ead;">case</span><span> INET_ECN_ECT_1:</span><span>
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>        </span><span style="color:#b48ead;">case</span><span> INET_ECN_CE:</span><span>
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">2</span><span>;</span><span>
</span><span>        }</span><span>
</span><span>    }</span><span>
</span><span>
</span><span>    *set_ce = </span><span style="color:#bf616a;">INET_ECN_is_ce</span><span>(outer);</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>So it looks like that in order for the log to be triggered, the inner IPv4 header's ECT bits
need to be 0, and the outer's need to be either ECT, or CE.</p>
<p><em>What are those terms, anyway?</em></p>
<p><a href="https://en.wikipedia.org/wiki/Explicit_Congestion_Notification">ECN</a>, or Explicit Congestion Notification, is a network feature that is used between routers to notify of
congestion.</p>
<p>ECT stands for ECN-Capabale-Transport.</p>
<p>In the IP header, the lower 2bits of the TOS field are used to indicate one of the following:</p>
<ul>
<li>00 - Non ECN-Capable Transport, Non-ECT</li>
<li>10 - ECN Capable Transport, ECT(0)</li>
<li>01 - ECN Capable Transport, ECT(1)</li>
<li>11 - Congestion Encountered, CE.</li>
</ul>
<p>So when a packet arrives where the external header has any bits set, and the internal one has none, we would see this log.
It seems to happen quite a lot, and it was easily verified with tcpdump:
<strong>All packets</strong> had <code>ECT(1)</code> on the outer header and <code>Non-ECT</code> on the inner.</p>
<p>This alone, however, should not cause traffic to drop.
Sorry, slip of the tongue - traffic wasn't dropped, per se, and you could see no trace of drops in <code>ip -s link</code>.</p>
<h2 id="minimal-reproducer">Minimal reproducer</h2>
<p>Well, nothing more could be done on a production environment.
Our product is too large and complex - our logs' SNR is too low.</p>
<p>Time to try and reproduce this in a vaccum:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> ip netns add A</span><span>
</span><span style="color:#bf616a;">$</span><span> ip netns add B</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> A link add _v0 type veth peer name _v1 netns B</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> A link set _v0 up</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> A addr add dev _v0 10.254.3.1/24</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> A route add default dev _v0 scope global</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> B link set _v1 up</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> B addr add dev _v1 10.254.1.6/24</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> B route add default dev _v1 scope global</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> B link add gre1 type gretap local 10.254.1.6 remote 10.254.3.1 key 0x49000000</span><span>
</span><span style="color:#bf616a;">$</span><span> ip</span><span style="color:#bf616a;"> -n</span><span> B link set gre1 up</span><span>
</span><span>
</span><span style="color:#65737e;"># Now send an IPv4/GRE/Eth/IPv4 frame where the outer header has ECT(1),</span><span style="color:#65737e;">
</span><span style="color:#65737e;"># and the inner header has no ECT bits set:</span><span style="color:#65737e;">
</span><span>
</span><span style="color:#bf616a;">$</span><span> cat send_pkt.py</span><span>
</span><span>    </span><span style="color:#65737e;">#!/usr/bin/env python3</span><span style="color:#65737e;">
</span><span>    </span><span style="color:#bf616a;">from</span><span> scapy.all import *</span><span>
</span><span>
</span><span>    </span><span style="color:#bf616a;">pkt</span><span> = IP(b&#39;</span><span style="color:#a3be8c;">E\x01\x00\xa7\x00\x00\x00\x00@/`%\n\xfe\x03\x01\n\xfe\x01\x06 \x00eXI\x00</span><span>&#39;</span><span>
</span><span>             </span><span style="color:#bf616a;">b</span><span>&#39;</span><span style="color:#a3be8c;">\x00\x00\x18\xbe\x92\xa0\xee&amp;\x18\xb0\x92\xa0l&amp;\x08\x00E\x00\x00}\x8b\x85</span><span>&#39;</span><span>
</span><span>             </span><span style="color:#bf616a;">b</span><span>&#39;</span><span style="color:#a3be8c;">@\x00\x01\x01\xe4\xf2\x82\x82\x82\x01\x82\x82\x82\x02\x08\x00d\x11\xa6\xeb</span><span>&#39;</span><span>
</span><span>             </span><span style="color:#bf616a;">b</span><span>&#39;</span><span style="color:#a3be8c;">3\x1e\x1e\\xf3\\xf7`\x00\x00\x00\x00ZN\x00\x00\x00\x00\x00\x00\x10\x11\x12</span><span>&#39;</span><span>
</span><span>             </span><span style="color:#bf616a;">b</span><span>&#39;</span><span style="color:#a3be8c;">\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !&quot;#$%&amp;\ ()*+,-./01234</span><span>&#39;</span><span>
</span><span>             </span><span style="color:#bf616a;">b</span><span>&#39;</span><span style="color:#a3be8c;">56789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><span>&#39;)</span><span>
</span><span>
</span><span>    </span><span style="color:#bf616a;">send</span><span>(pkt)</span><span>
</span><span style="color:#bf616a;">$</span><span> sudo ip netns exec B tcpdump</span><span style="color:#bf616a;"> -neqlllvi</span><span> gre1 icmp &amp; ; </span><span style="color:#bf616a;">sleep</span><span> 1</span><span>
</span><span style="color:#bf616a;">$</span><span> sudo ip netns exec A python3 send_pkt.py</span><span>
</span></code></pre>
<p>This packet is an <code>IPv4/GRE/Ethernet/IPv4/ICMP(echo request)</code> packet - a ping over a GRE-tap.
Sure enough, this was enough to trigger this bug on my Ubuntu 20.04 machine (Kernel v5.4), and on a few of my friends' machines (Kernel v5.12).</p>
<p>Running this script on the previous version of Ubuntu we used, 18.04 (Kernel 4.15), did not trigger the bug.</p>
<p>Want to try it yourself? If <code>tcpdump</code> reports a packet with a destination of <code>18:be:92:a0:ee:26</code>, you're golden.
If you see <code>18:bd:92:a0:ee:26</code> instead; oh well.</p>
<h2 id="what-a-coincidence">What a coincidence</h2>
<p>Haha, what are the chances? The bits in the destination MAC address that were overriden are in the same offset within the ethernet address as the ECT bits are in the IPv4 header</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span> Ethernet Header</span><span>
</span><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ - - -</span><span>
</span><span>â”‚Dest (6B)                â”‚Src (6B)</span><span>
</span><span>â”‚                         â”‚</span><span>
</span><span>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ - - -</span><span>
</span><span> IPv4 Header</span><span>
</span><span>â”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ - - -</span><span>
</span><span>â”‚Verâ”‚TOS       â”‚</span><span>
</span><span>â”‚1B â”‚(2B)      â”‚</span><span>
</span><span>â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ - - -</span><span>
</span></code></pre>
<p>That's obviously related, but we couldn't find anything related to it in the code we've inspected.</p>
<h2 id="finding-the-culprit">Finding the culprit</h2>
<p>So now we now we know that somewhere between Ubuntu 18.04 and Ubuntu 20.04, or more precisely, between kernel versions 4.15 and 5.4,
someone submitted a patch introducing this bug.</p>
<p>We started by looking at <code>git log --grep=' ECT' v4.15...v5.4</code>'s output, and certainly found some interesting stuff,
but nothing that would explain the bug.</p>
<p>Before going further into code-reading mode, we wanted to narrow down the bug's location even further, so we set up some vagrant boxes and
found that Ubuntu 19.04 (Kernel Version 5.0) is free of the bug, and that Ubuntu 19.10 (5.3) is already bugged.</p>
<p>Can we narrow it down even further with minimal effort, without going over the code?</p>
<p><span title="Narrator: they couldn't" style="border-bottom: 1px dotted #000;">Sure we can!</span>
Ubuntu even supplies <a href="https://wiki.ubuntu.com/Kernel/MainlineBuilds">this handy guide</a> for installing <em>mainline</em> kernel versions.</p>
<p>Starting with an Ubuntu 19.04 we started to upgrade our kernel version minor-by-minor, waiting for the bug to reproduce.</p>
<ul>
<li>5.1: CLEAR!</li>
<li>5.2: CLEAR!</li>
<li>5.2.10: CLEAR!</li>
<li>5.2.21: CLEAR!</li>
</ul>
<p>Wow! v5.2.21 is the last version before v5.3.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$ git log --grep=&#39; ECT&#39; v5.2.21..v5.3</span><span>
</span></code></pre>
<p>Nothing.</p>
<p>Out of curiosity, I went back to the vagrant box and installed the deb package for kernel v5.3, the one we know is bugged.</p>
<p>No reproduction.</p>
<p>v5.4? No reproduction.</p>
<p>What?...</p>
<h2 id="ubuntu-kernel-vanilla-kernel">Ubuntu Kernel != Vanilla Kernel</h2>
<p>Okay, so I've messed up.
You might have guessed it, but all of this time I've been operating under this implicit assumption
that the kernel that's shipped with with Ubuntu is the regular, mainline, vanilla, stock kernel.</p>
<p>Good ol' kernel.</p>
<p>But this is obviously false - Ubuntu's release model doesn't allow it just upgrade any software version to the next major version. But if the software stays the same over time, it will not get any security fixes.
So Ubuntu's maintainers do what any reasonable maintainer does - they backport patchsets from newer kernel versions.</p>
<p>The kernels the come with Ubuntu out-of-the-box are patched, but the kernels that are provided in https://wiki.ubuntu.com/Kernel/MainlineBuilds, are, well, mainline.</p>
<p>So this bug, presumably, was either backported from a later version, or introduced by a botched application of a patch.</p>
<p>We also know that this bug was reproduced on my friends' machines (BTW they run Arch); both of them with newer kernels, so the latter option can be eliminated.</p>
<p>Time to keep bisecting.</p>
<p><strong>20 minutes later</strong></p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">â¯</span><span> git log</span><span style="color:#bf616a;"> --grep</span><span>=&#39;</span><span style="color:#a3be8c;"> ECT</span><span>&#39; v5.6..v5.7</span><span>
</span><span style="color:#bf616a;">commit</span><span> b723748750ece7d844cdf2f52c01d37f83387208</span><span>
</span><span style="color:#bf616a;">Author:</span><span> Toke HÃ¸iland-JÃ¸rgensen &lt;toke@redhat.com&gt;</span><span>
</span><span style="color:#bf616a;">Date:</span><span>   Mon Apr 27 16:11:05 2020 +0200</span><span>
</span><span>
</span><span>    </span><span style="color:#bf616a;">tunnel:</span><span> Propagate ECT(1) </span><span style="color:#bf616a;">when</span><span> decapsulating as recommended by RFC6040</span><span>
</span><span>
</span><span>    </span><span style="color:#bf616a;">RFC</span><span> 6040 recommends propagating an ECT(1) </span><span style="color:#bf616a;">mark</span><span> from an outer tunnel header</span><span>
</span><span>    </span><span style="color:#bf616a;">to</span><span> the inner header if that inner header is already marked as ECT(0)</span><span style="color:#96b5b4;">.</span><span> When</span><span>
</span><span>    </span><span style="color:#bf616a;">RFC</span><span> 6040 decapsulation was implemented, this case of propagation was not</span><span>
</span><span>    </span><span style="color:#bf616a;">added.</span><span> This simply appears to be an oversight, so let&#39;</span><span style="color:#a3be8c;">s fix that.</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">    Fixes: eccc1bb8d4b4 (&quot;tunnel: drop packet if ECN present with not-ECT&quot;)</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">    Reported-by: Bob Briscoe &lt;ietf@bobbriscoe.net&gt;</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">    Reported-by: Olivier Tilmans &lt;olivier.tilmans@nokia-bell-labs.com&gt;</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">    Cc: Dave Taht &lt;dave.taht@gmail.com&gt;</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">    Cc: Stephen Hemminger &lt;stephen@networkplumber.org&gt;</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">    Signed-off-by: Toke HÃ¸iland-JÃ¸rgensen &lt;toke@redhat.com&gt;</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;</span><span style="color:#a3be8c;">
</span></code></pre>
<p>haha, hey there ğŸ‘‰ğŸ‘ˆ</p>
<p>Well, the description does not fit our scenario exactly, if we look at the IPv4 headers.
But evidently the kernel doesn't look at the inner IPv4 header either, it looks at the Ethernet header.</p>
<p>Considering this, not much mystery is left:</p>
<p>When Toke's code is seeing our IPv4 packets, it tries to read the TOS field to extract the ECT bits.
Due to some confusion, it extracts the second byte of the destination MAC address, and later conditionally modifies it.</p>
<p>Since we set a different MAC address on the GRE depending on the machine we're running on, this bug would not reproduce in all setups.
IPv6 traffic is also presumably affected, it's just that the ECT bits are in a <em>slightly</em> different offset.</p>
<h2 id="finding-a-fix">Finding a fix</h2>
<p>Enough talk, let's look at some code.</p>
<p>Toke's code modifies <code>IP_ECN_decapsulate</code> to apply the RFC6040 recommendation.
<code>IP_ECN_decapsulate</code> receives the outer ip-header as an argument, as well as an <code>struct sk_buff *skb</code>, from which it extracts the inner header.</p>
<p>An <code>skb</code> is a struct used inside the kernel to process packets. <sup><a href="http://vger.kernel.org/%7Edavem/skb.html">[1]</a></sup></p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>struct sk_buff {</span><span>
</span><span>/* members truncated */</span><span>
</span><span>    __be16          protocol;           // Current protocol in process</span><span>
</span><span>    __u16           transport_header;   // Offset to the transport header</span><span>
</span><span>    __u16           network_header;     // Offset to the network header</span><span>
</span><span>    __u16           mac_header;         // Offset to the mac header</span><span>
</span><span>/* members truncated */</span><span>
</span><span>    unsigned char       *head,          // Pointer to the start of the packet</span><span>
</span><span>                *data;                  // Cursor pointing to the current poisition in the buffer</span><span>
</span><span>/* members truncated */</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>Toke's using the <code>ip_hdr</code> function to extract the inner header from the skb:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>static inline struct iphdr *ip_hdr(const struct sk_buff *skb)</span><span>
</span><span>{</span><span>
</span><span>    return (struct iphdr *)skb_network_header(skb);</span><span>
</span><span>}</span><span>
</span><span>
</span><span>// ...</span><span>
</span><span>
</span><span>static inline unsigned char *skb_network_header(const struct sk_buff *skb)</span><span>
</span><span>{</span><span>
</span><span>    return skb-&gt;head + skb-&gt;network_header;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>It looks like <code>skb-&gt;network_header</code> is set to the wrong offset in our case, where is that little set?
Oh, it turns out we've been here before:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">// net/ipv4/ip_tunnel.c ~L393</span><span style="color:#65737e;">
</span><span>    </span><span style="color:#bf616a;">skb_reset_network_header</span><span>(skb); </span><span style="color:#65737e;">// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><span style="color:#65737e;">
</span><span>    </span><span style="color:#65737e;">// ^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span style="color:#65737e;">
</span><span>
</span><span>    err = </span><span style="color:#bf616a;">IP_ECN_decapsulate</span><span>(iph, skb);</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">unlikely</span><span>(err)) {</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>(log_ecn_error)</span><span>
</span><span>            </span><span style="color:#bf616a;">net_info_ratelimited</span><span>(&quot;</span><span style="color:#a3be8c;">non-ECT from </span><span style="color:#d08770;">%p</span><span style="color:#a3be8c;">I4 with TOS=</span><span style="color:#d08770;">%#x</span><span style="color:#96b5b4;">\n</span><span>&quot;,</span><span>
</span><span>                    &amp;iph-&gt;saddr, iph-&gt;tos);</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>(err &gt; </span><span style="color:#d08770;">1</span><span>) {</span><span>
</span><span>            ++tunnel-&gt;dev-&gt;stats.</span><span style="color:#bf616a;">rx_frame_errors</span><span>;</span><span>
</span><span>            ++tunnel-&gt;dev-&gt;stats.</span><span style="color:#bf616a;">rx_errors</span><span>;</span><span>
</span><span>            </span><span style="color:#b48ead;">goto</span><span> drop;</span><span>
</span><span>        }</span><span>
</span><span>    }</span><span>
</span><span>
</span><span style="color:#65737e;">// ...</span><span style="color:#65737e;">
</span><span>
</span><span style="color:#65737e;">// Gilad: Set the offset of the network header to the cursor</span><span style="color:#65737e;">
</span><span style="color:#b48ead;">static inline void </span><span style="color:#8fa1b3;">skb_reset_network_header</span><span>(</span><span style="color:#b48ead;">struct</span><span> sk_buff *</span><span style="color:#bf616a;">skb</span><span>)</span><span>
</span><span>{</span><span>
</span><span>    skb-&gt;network_header = skb-&gt;data - skb-&gt;head;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>At this point in the processing pipeline, the kernel just stripped the tunnel header and starts to process the next header.
When the tunnel is a regular GRE (probably most of the time), the next header is a network header (IPv4/IPv6/etc.), so setting the network header offset to the cursor makes sense.</p>
<p>Since we use GRE-tap (probably rare), the next header is sadly, an Ethernet header, rendering this reset incorrect.
We need to make sure that the correct offset is set:</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="color:#bf616a;">-	skb_reset_network_header(skb);</span><span>
</span><span style="color:#a3be8c;">+	skb_set_network_header(skb, (tunnel-&gt;dev-&gt;type == ARPHRD_ETHER) ? ETH_HLEN : 0);</span><span>
</span></code></pre>
<h2 id="tl-dr">tl;dr</h2>
<p>Kernel got confused between headers; <a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=227adfb2b1df">patched via one line</a>.</p>
<h2 id="the-correct-fix">The correct fix</h2>
<p>A friend of mIne which uSuAlly wAnts to remain anonymous, notiCed that problem is a bit larger than that particular piece of code in <code>ip_tunnel.c</code>.</p>
<p>For a brief moment in the pipeline, the <code>skb</code> struct is invalid: <code>skb-&gt;protocol</code> tells us that the next protocol is IPv4, but <code>data</code> points to the start of the Ethernet header.</p>
<p>He proposed the following patch and asked me to send it to the mailing list, but sadly I'm too lazy to do so.</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c</span><span>
</span><span>index 0dca00745ac3..1bd14fa66d74 100644</span><span>
</span><span>--- a/net/ipv4/ip_tunnel.c</span><span>
</span><span>+++ b/net/ipv4/ip_tunnel.c</span><span>
</span><span>@@ -390,6 +390,19 @@ </span><span style="color:#8fa1b3;">int ip_tunnel_rcv(struct ip_tunnel *tunnel, struct sk_buff *skb,</span><span>
</span><span> 		tunnel-&gt;i_seqno = ntohl(tpi-&gt;seq) + 1;</span><span>
</span><span> 	}</span><span>
</span><span> </span><span>
</span><span style="color:#a3be8c;">+	if (tunnel-&gt;dev-&gt;type == ARPHRD_ETHER) {</span><span>
</span><span style="color:#a3be8c;">+		if (!pskb_may_pull(skb, ETH_HLEN)) {</span><span>
</span><span style="color:#a3be8c;">+			tunnel-&gt;dev-&gt;stats.rx_length_errors++;</span><span>
</span><span style="color:#a3be8c;">+			tunnel-&gt;dev-&gt;stats.rx_errors++;</span><span>
</span><span style="color:#a3be8c;">+			goto drop;</span><span>
</span><span style="color:#a3be8c;">+		}</span><span>
</span><span style="color:#a3be8c;">+</span><span>
</span><span style="color:#a3be8c;">+		skb-&gt;protocol = eth_type_trans(skb, tunnel-&gt;dev);</span><span>
</span><span style="color:#a3be8c;">+		skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);</span><span>
</span><span style="color:#a3be8c;">+	} else {</span><span>
</span><span style="color:#a3be8c;">+		skb-&gt;dev = tunnel-&gt;dev;</span><span>
</span><span style="color:#a3be8c;">+	}</span><span>
</span><span style="color:#a3be8c;">+</span><span>
</span><span> 	skb_reset_network_header(skb);</span><span>
</span><span> </span><span>
</span><span> 	err = IP_ECN_decapsulate(iph, skb);</span><span>
</span><span>@@ -407,13 +420,6 @@ </span><span style="color:#8fa1b3;">int ip_tunnel_rcv(struct ip_tunnel *tunnel, struct sk_buff *skb,</span><span>
</span><span> 	dev_sw_netstats_rx_add(tunnel-&gt;dev, skb-&gt;len);</span><span>
</span><span> 	skb_scrub_packet(skb, !net_eq(tunnel-&gt;net, dev_net(tunnel-&gt;dev)));</span><span>
</span><span> </span><span>
</span><span style="color:#bf616a;">-	if (tunnel-&gt;dev-&gt;type == ARPHRD_ETHER) {</span><span>
</span><span style="color:#bf616a;">-		skb-&gt;protocol = eth_type_trans(skb, tunnel-&gt;dev);</span><span>
</span><span style="color:#bf616a;">-		skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);</span><span>
</span><span style="color:#bf616a;">-	} else {</span><span>
</span><span style="color:#bf616a;">-		skb-&gt;dev = tunnel-&gt;dev;</span><span>
</span><span style="color:#bf616a;">-	}</span><span>
</span><span style="color:#bf616a;">-</span><span>
</span><span> 	if (tun_dst)</span><span>
</span><span> 		skb_dst_set(skb, (struct dst_entry *)tun_dst);</span><span>
</span><span> </span><span>
</span><span>diff --git a/net/ipv4/ip_tunnel_core.c b/net/ipv4/ip_tunnel_core.c</span><span>
</span><span>index 6b2dc7b2b612..c9010cebb936 100644</span><span>
</span><span>--- a/net/ipv4/ip_tunnel_core.c</span><span>
</span><span>+++ b/net/ipv4/ip_tunnel_core.c</span><span>
</span><span>@@ -105,7 +105,7 @@ </span><span style="color:#8fa1b3;">int __iptunnel_pull_header(struct sk_buff *skb, int hdr_len,</span><span>
</span><span> </span><span>
</span><span> 		eh = (struct ethhdr *)skb-&gt;data;</span><span>
</span><span> 		if (likely(eth_proto_is_802_3(eh-&gt;h_proto)))</span><span>
</span><span style="color:#bf616a;">-			skb-&gt;protocol = eh-&gt;h_proto;</span><span>
</span><span style="color:#a3be8c;">+			skb-&gt;protocol = htons(ETH_P_802_3);</span><span>
</span><span> 		else</span><span>
</span><span> 			skb-&gt;protocol = htons(ETH_P_802_2);</span><span>
</span><span> </span><span>
</span><span>diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span><span>
</span><span>index 322698d9fcf4..afeba4ebc6e2 100644</span><span>
</span><span>--- a/net/ipv6/ip6_tunnel.c</span><span>
</span><span>+++ b/net/ipv6/ip6_tunnel.c</span><span>
</span><span>@@ -822,8 +822,6 @@ </span><span style="color:#8fa1b3;">static int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,</span><span>
</span><span> 		tunnel-&gt;i_seqno = ntohl(tpi-&gt;seq) + 1;</span><span>
</span><span> 	}</span><span>
</span><span> </span><span>
</span><span style="color:#bf616a;">-	skb-&gt;protocol = tpi-&gt;proto;</span><span>
</span><span style="color:#bf616a;">-</span><span>
</span><span> 	/* Warning: All skb pointers will be invalidated! */</span><span>
</span><span> 	if (tunnel-&gt;dev-&gt;type == ARPHRD_ETHER) {</span><span>
</span><span> 		if (!pskb_may_pull(skb, ETH_HLEN)) {</span><span>
</span></code></pre>
<h2 id="kpatch">kpatch</h2>
<p>(TODO)</p>
<h4 id="delete-this-drafts">DELETE THIS (drafts)</h4>
<p>Well, no choice but use the ultimate tool for diagnosing network problems â€” helplessly staring at various <code>tcpdump</code>s with differing options.</p>


           </div>
       </section>
    </body>
</html>

